<!DOCTYPE html>
<html>
  <head>
    <title>Disjoint Set / Union Find</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <link href="css/slides.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <textarea id="source">

class: center, top

<br><br>

# CSCI-UA 480.4: APS
## Algorithmic Problem Solving
<br>
## Non-Linear Data Structures


.author[
Instructor: Joanna Klukowska <br>

created based on materials for this class by Bowen Yu and
materials shared by the authors of the textbook  Steven and Felix Halim

]

.license[
Unless noted otherwise all content is released under [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/).
]


---

# Disjoint Set / Union-Find

- tracks a set of elements partitioned into disjoint subsets

    - disjoint?


---

# Disjoint Set / Union-Find

- tracks a set of elements partitioned into disjoint subsets

    - disjoint? - non overlapping, no elements in common

--

- performance: near constant time (bound by inverse [Ackerman function](https://en.wikipedia.org/wiki/Ackermann_function))
  for
    - `find(x)` - determine which set an element belongs to
    - `sameSet(x,y)` - determine if x and y belong to the same set
    - `union(x,y)` - merge two sets  of which x and y are members

- the above performance assumes
    - path compression
    - merging by rank

---
## Example


.center[<img src="img/union_find_1.png" alt="union-find" width = "75%"/>]

---
## Example


.center[<img src="img/union_find_2.png" alt="union-find" width = "75%"/>]

--

union(0,1)<br>
union(6,8)


---
## Example


.center[<img src="img/union_find_3.png" alt="union-find" width = "75%"/>]

--

union(4,6)<br>
(uses merging by rank: the _tree_ with higher approximate height
becomes the root)


---
## Example


.center[<img src="img/union_find_4.png" alt="union-find" width = "75%"/>]

--

union(3,7)<br>
union(2,9) <br>
union(9,3)


---
## Example


.center[<img src="img/union_find_5.png" alt="union-find" width = "75%"/>]

--

find(7) <br>
(uses path compression)

---

# Visualizations:

- [USFCA visualization](https://www.cs.usfca.edu/~galles/visualization/Heap.html)

- [VisuAlgo](hhttps://visualgo.net/en/ufds)



---
# Challenge

There are N students ( 2 <= N <= 10^5). Each student belongs to exactly
one student club. We do not know what clubs the students belong to, but we
do have information about pairs of students who belong to the same club.
This information is presented in the form of pairs: (a,b) - this indicates
that the students a and b belong to the same student club.
We have P (1 <= P <= 10^5) such pairs. The pairs are not guaranteed to be
unique.

Find the number of student clubs on campus.

__Example:__

n = 5, (so at most 5 clubs)

list of pairs:
```
(1,2)
(1,4)
(3,5)
(2,4)
```

--

__Answer__ There are two student clubs.



---
# Challenge: Allies and Enemies

There are N countries ( 2 <= N <= 10^5). Any pair of countries are either allies
or enemies.


Instructions to be implemented:

- `ally(x,y)`, x and y are allies
- `enemy(x,y)`, x and y are enemies
- `isAlly(x,y)`, queries about being allies
- `isEnemy(x,y)`, queries about being enemies

(if an instruction `ally` or `enemy` conflicts with existing information,
it should be ignored and a conflict should be reported )

We have the following relations:

- if  `ally(x,y)` and `ally(y,z)` then `ally(x,z)`
- if  `ally(x,y)` and `enemy(y,z)` then `enemy(x,z)`
- if  `enemy(x,y)` and `ally(y,z)` then `enemy(x,z)`
- if  `enemy(x,y)` and `enemy(y,z)` then `ally(x,z)`

---

# Challenge: Allies and Enemies
## Example

n = 5, (countries numbered 1 - 5)

|instructions | response |
|:---|:---|
|`isAlly(1,2)` | false, no info yet |
|`isEnemy(1,2)` | false, no info yet |
|`ally(1,2)` | OK (i.e., no conflict) |
|`ally(3,4)` | OK (i.e., no conflict) |
|`enemy(1,2)` | conflict |
|`enemy(1,4)` | OK (i.e., no conflict) |
|`isEnemy(1,3)` | true |
|`enemy(1,5)` | OK (i.e., no conflict) |
|`isAlly(2,5)` | false  |
|`isAlly(3,5)` | true  |
|`enemy(4,5)` | conflict  |

---

# Challenge: Allies and Enemies
## Solution

Represent each country with two values: x and x'

The required instructions can be now implemented using disjoint set at follows:

- ally(x,y)
    - if sameSet(x,y'), then conflict
    - otherwise union(x,y) and union(x',y')
- enemy(x,y)
    - if sameSet(x,y), then conflict
    - otherwise union(x,y`) and union(x',y)
- isAlly(x,y)
    - return sameSet(x,y)
- isEnemy(x,y)
    - return sameSet(x,y')

---

# Challenge: Allies and Enemies
## Example Solution

n = 5, (countries numbered 1 - 5)

|instructions | response | disjoint set |
|:---|:---|:---|
| | |                                    `/ 1 / 2 / 3 / 4 / 5 / 1'/ 2'/ 3'/ 4'/ 5'/ ` |
|`isAlly(1,2)` | false, no info yet |    `/-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 / ` |
|`isEnemy(1,2)` | false, no info yet |   `/-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 /-1 / ` |
|`ally(1,2)` | OK (i.e., no conflict) |  `/-2 / 1 /-1 /-1 /-1 /-2 / 1'/-1 /-1 /-1 / ` |
|`ally(3,4)` | OK (i.e., no conflict) |  `/-2 / 1 /-2 / 3 /-1 /-2 / 1'/-2 / 3'/-1 / ` |
|`enemy(1,2)` | conflict |               `/-2 / 1 /-2 / 3 /-1 /-2 / 1'/-2 / 3'/-1 / ` |
|`enemy(1,4)` | OK (i.e., no conflict) | `/-4 / 1 / 1'/ 3 /-1 /-4 / 1'/ 1 / 3'/-1 / ` |
|`isEnemy(1,3)` | true |                 `/-4 / 1 / 1'/ 3 /-1 /-4 / 1'/ 1 / 3'/-1 / ` |
|`enemy(1,5)` | OK (i.e., no conflict) | `/-5 / 1 / 1'/ 3 / 1'/-5 / 1'/ 1 / 3'/ 1 / ` |
|`isAlly(2,5)` | false  |                `/-5 / 1 / 1'/ 3 / 1'/-5 / 1'/ 1 / 3'/ 1 / ` |
|`isAlly(4,5)` | true  |                 `/-5 / 1 / 1'/ 1'/ 1'/-5 / 1'/ 1 / 3'/ 1 / ` *|
|`enemy(4,5)` | conflict  |              `/-5 / 1 / 1'/ 1'/ 1'/-5 / 1'/ 1 / 3'/ 1 / `|

* path compression

---

# Challenge: Build a Maze

Given an NxN grid generate a random maze.

- we have a fixe start point and end point

- there should be no cycles in the maze

- every cell should be reachable from every other cell

---
# Challenge: Building a Maze


__Algorithm__:

- create a set of all internal walls
- choose a wall at random
- if that wall on each side of this wall are not in the same set,
    - then erase it (union the two sets in which they are in) -> this avoids cycles
- repeat until all cells are in the same set (each cell is reachable
from every other cell)

---
# Challenge: Counting Islands

There NxM grid of integers gives terrain elevation. Given a water level L, every
cell with the height (=elevation) <= L is below the water. The islands are the cells
above the water.

Determine the number of islands.












</optgroup>



    </textarea>
     <script src="js/remark.js" type="text/javascript">
    </script>
    <script src="js/remark_conf.js" type="text/javascript">
    </script>

    <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<script type="text/x-mathjax-config">
   MathJax.Hub.Config({
     extensions: ["tex2jax.js"],
     jax: ["input/TeX", "output/HTML-CSS"],
     tex2jax: {
       inlineMath: [ ['$','$'], ["\\(","\\)"] ],
       displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
       processEscapes: true
     },
     "HTML-CSS": { availableFonts: ["TeX"] }
   });
</script>


  </body>
</html>
